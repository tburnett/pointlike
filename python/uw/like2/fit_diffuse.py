"""
Fit diffuse 
"""
import os, glob, pickle
import numpy as np
import pylab as plt
import pandas as pd
from skymaps import SkyDir, Band 
from . import ( diffuse, maps,)


def fitter(roi, nbands=8, gal_only=True, folder='diffuse_fit_maps', 
    corr_min=-0.95, update=False, batch=True):
    """
    Perform independent fits to the gal, iso for each of the first nbands bands.
    If such a fit fails, or the correlation coeficient less than corr_min, fit only the isotropic.
    select: None or list of variables
    update: if True, modify the correction coefficients

    If select==[0]: do gal only, with iso fixed at 1.
    """

    # thaw gal and iso
    dnames = dict(gal='gal', iso='iso') if 'gal' in roi.sources.source_names\
        else dict(gal='ring', iso='isotrop')

    select = [0] if gal_only else [0,1]

    roi.thaw('Norm', dnames['gal'])
    if not gal_only:
        roi.thaw('Scale', dnames['iso'])
        roi.get_model(dnames['iso']).bounds[0]=[np.log10(0.5), np.log10(10.0)] # set limits 
    roi.reinitialize()
    
    # do the fitting
    dpars=[]
    energies = []
    covs=[]
    quals = []
    def corr(cov): # correlation coeficiant
        return cov[0,1]/np.sqrt(cov[0,0]*cov[1,1])
    for ie in range(nbands):
        roi.select(ie); 
        energy =int(roi.energies[0]) 
        print '----- E={} {} -----'.format(energy, select)
        roi.fit( select,  ignore_exception=True) #,setpars={0:1, 1:1},
        cov = roi.fit_info['covariance']
        if not gal_only and (cov is None or len(cov)<2 or cov[0,0]<0 or corr(cov)<corr_min):
            #fail, probably since too correlated, or large correlation. So fit only iso
            roi.fit([1], setpars={0:0, 1:0}, ignore_exception=True)
            cov=np.array([ [0, roi.fit_info['covariance'][0]] , [0,0] ])
            print 'set cov: {}'.format(cov)
        energies.append(energy)
        dpars.append( roi.sources.parameters.get_parameters()[:2])
        covs.append(cov)
        quals.append(roi.fit_info['qual'])
    roi.freeze('Norm', dnames['gal'], 1.0)
    if not gal_only: roi.freeze('Scale', dnames['iso'], 1.0)
    roi.select() # restore

    
    # set to external pars
    # Warning
    df = pd.DataFrame(np.power(10,np.array(dpars)[:,0]), columns=['gal'] if gal_only else 'gal iso'.split())
    df['cov'] = covs
    df['qual'] = quals
    df.index=energies

    if folder is not None:

        if folder=='diffuse_fit_maps':
            if not os.path.exists(folder):
                os.mkdir(folder)
            # new: generate maps instead
            dfa = FitAnalysis(roi, diffuse_fits=df)
            t=dfa.process_bands()
            filename= '{}/{}.pickle'.format(folder, roi.name)
            pickle.dump(t, open(filename, 'w'))
            print 'wrote file {}'.format(filename)

            folder = 'diffuse_fit'
            #old logic
            # save results for diagnostic plots
            if not os.path.exists(folder):
                os.mkdir(folder)
            filename= '{}/{}.pickle'.format(folder, roi.name)
            pickle.dump(df, open(filename, 'w'))
            print 'wrote file {}'.format(filename)
    
    if update:
        # check keys: if set, update, otherwise store fit value
        gal_key = roi.config.diffuse[dnames['gal']].get('key', '')=='gal'
        iso_key = roi.config.diffuse[dnames['gal']].get('key', '')=='iso'
        # update correction factors, reload all response objects
        dn=diffuse.normalization
        
        if gal_key:
            dn['gal'] *= df.gal.values
        else:
            dn['gal'] = df.gal.values
        if iso_key:
            dn['iso']['front'] *= df.iso.values
            dn['iso']['back'] *= df.iso.values
        elif 'iso' in dn and not gal_only:
            dn['iso']['front'] = df.iso.values
            dn['iso']['back']  = df.iso.values

        # now reload
        for band in roi:
            for res in band[:2]:
                assert res.source.isglobal
                res.setup=False
                res.initialize()
        print 'Updated coefficients'
    if batch: return

    # for interactive: convert covariance matrix to sigmas, correlation
    gsig=[]; isig=[]; corr=[]
    for i in range(len(df)):
        c = df.iloc[i]['cov']
        if len(select)==2:
            diag = np.sqrt(c.diagonal())
            gsig.append(diag[0])
            isig.append(diag[1])
            corr.append(c[0,1]/(diag[0]*diag[1]))
        elif select==[0]:
            gsig.append(np.sqrt(c[0]))
            corr.append(0)
            isig.append(0)
            
    df['gsig']=gsig
    df['isig']=isig 
    df['corr']=corr

    del df['cov']

    return df
    

class FitAnalysis(object):
    """Process diffuse analysis, as generated by the fitter
    """
    def __init__(self, roi, roi_index=None, diffuse_fits=None, nside=64):
        """
        """
        self.roi = roi
        if roi_index is not None:
            print "setting up index {}".format(roi_index)
            roi.setup_roi(roi_index) # Process object external for now
        else:
            roi_index = int(roi.name[-4:])
        self.ri = roi_index
        self.pdirs = map(Band(nside).dir, maps.make_index_table(12,nside)[roi_index])
        print 'Processing ROI index {}'.format(roi_index)

        # load diffuse fits for this model
        if diffuse_fits is None:
            files = sorted(glob.glob('diffuse_fit/*.pickle'))
            assert len(files)>0, 'no files found'
            if len(files)<1728:
                msg= "found {} files, expected 1728".format(len(files))
                print msg
                raise Exception(msg)
            # return as an array 1728x8x2, last being (gal,iso)
            self.fa = (pd.read_pickle(files[roi_index]).values[:,:2]).astype(float)
            print 'Loaded diffuse fits for this RoI'
        else:
            self.fa = diffuse_fits.values[:,:2].astype(float)
            print 'Using fits just generated'

        
    def select_band(self, index):
        self.roi.select(index, event_type=None)
        energies = self.roi.energies
        assert len(energies)==1
        self.energy=energies[0]
        print 'Selected {:.0f} MeV'.format(self.energy)
        
        # get the counts in each pixel for gal,iso, and for [front] or [front,back] 
        self.dflux = np.array([[map(resp, self.pdirs)\
                                for resp in sb[:2]] for sb in self.roi.selected])
        
        m = self.dflux.mean(axis=2); s = self.dflux.std(axis=2)/m
        #for a,b in zip(m,s): print '{:8.0f}, {:.3f}'.format(a,b)
        
    
    def process_band(self, iband, verbose=False):

        self.select_band(iband)

        dflux= self.dflux.astype(float)
        if verbose:
            m = dflux.mean(axis=2); s = dflux.std(axis=2)/m
            ids = 'Front Back'.split() if dflux.shape[0]==2 else ['Front']
            print 'mean\n', pd.DataFrame(m, index=ids, columns='gal iso'.split())
            print 'rms/mean\n',pd.DataFrame(s, index=ids, columns='gal iso'.split())

        x=self.fa[iband,:] 
        if verbose: print 'Fits\n', x

        a64=Band(64).pixelArea()
        f=(dflux*a64); 

        # iso/gal ratio
        r = f[:,1,:]/f[:,0,:]; 
        if verbose: print 'ratio\n', r

        # adjusted fits per (flux, pixel)
        af = x[0] + r*(x[1]-1); 
        if verbose: print 'adjusted fits\n',af

        # isolate the galactic flux
        f_gal = f[:,0]; 
        if verbose: print 'galactic fit\n',f_gal

        # weighted sum of the adjusted fits by the galactic flux
        waf = (f_gal*af).sum(axis=0) / f_gal.sum(axis=0);  
        if verbose: print 'weighted fit\n',self.waf
        return waf
        
    def process_bands(self, ibands=range(8)):
        return np.array([self.process_band(iband) for iband in ibands])